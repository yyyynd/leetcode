package leetCode2021_05_09;

/**
 * 在考虑递归求解时（有的题确实递归更优或实现简单）
 * 而且很多时候会产生重复计算的情况，这时候就要考虑用map或者set进行剪枝了
 *
 * 这题也是一个迫近目标值的题型，思路上肯定是希望通过大量的除2快速迫近，但这里问题就是
 * 提供了加1和减1两种手段，这在数为奇数时就要考虑两种情况了
 *
 * 考虑一种情况，如果在减1，除2后，这个数又为奇数了，肯定又要继续加减1的操作才能除2了
 * 但如果加1，除2后，这个数还是偶数，那么可以继续执行除2，很明显第二种在这个范围上进行的操作
 * 明显会使得总操作数比第一种少1步，这也符合我们贪心算法尽量多执行除2操作的理念
 *
 * 那么很明显，如果我们在每次遇到奇数情况时都这样考虑一下，得出在局部范围使用加减1最少的操作
 * ，最终推出的结果就会是最优解
 *
 *
 * 第二种方法递归，通过剪枝进行优化也很合理，我只要有[2,i-1]迫近到1的最优解，
 * 就可以很容易得出i迫近到1的最优解
 *
 * 这里还要考虑到数据位数的问题，因为最大数据位2的32次方-1，就是为int类型的最大数了
 * 那么在实际执行计算操作的时候会导致位的溢出，因为2的32次方-1明显奇数，我们的判断流程
 * 应该是会判断给其执行+1操作，这就导致数据上溢出了
 *
 * 这也提醒如果结果错误，要注意很可能是数据溢出的问题
 */
public class k397 {
    public int integerReplacement(int n) {
        int count = 0;
        long x = n;
        while (x > 1){
            if(x % 2 == 1){
                count += 2;
                if( (x-1)/2%2 == 1) {
                    //特别考虑3是因为，3这里判断得出1是奇数，虽然根据流程应该执行+1，但1就是结果了
                    //如果+1 /2得2 再/2 明显多一步
                    if( x != 3)
                        x = (x + 1) / 2;
                    else
                        x = 1;
                } else
                    x = (x-1)/2;
            }else {
                count++;
                x /= 2;
            }//else
        }//while

        return count;
    }
}
